"use strict";(self.webpackChunkmicrogreen_data_service_docs=self.webpackChunkmicrogreen_data_service_docs||[]).push([[534],{660:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=t(5893),r=t(1151);const a={sidebar_position:3,description:"Why React Query?"},s="React Query",l={id:"frontend/react-query",title:"React Query",description:"Why React Query?",source:"@site/docs/frontend/react-query.md",sourceDirName:"frontend",slug:"/frontend/react-query",permalink:"/Microgreen_Data_Service_Docs/frontend/react-query",draft:!1,unlisted:!1,editUrl:"https://github.com/MicrogreenSolarCorp/Microgreen_Data_Service_Docs/docs/frontend/react-query.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,description:"Why React Query?"},sidebar:"sidebar",previous:{title:"PWA",permalink:"/Microgreen_Data_Service_Docs/frontend/pwa"},next:{title:"Web Bluetooth",permalink:"/Microgreen_Data_Service_Docs/frontend/web-bluetooth"}},o={},c=[{value:"Problem 1",id:"problem-1",level:2},{value:"Solution 1: Frontend Caching",id:"solution-1-frontend-caching",level:2},{value:"Overview:",id:"overview",level:3},{value:"Types of Caches",id:"types-of-caches",level:3},{value:"Local Session",id:"local-session",level:4},{value:"IndexedDB",id:"indexeddb",level:4},{value:"Tanstack Query",id:"tanstack-query",level:3},{value:"Tanstack Query Options",id:"tanstack-query-options",level:3},{value:"Problem 1a)",id:"problem-1a",level:2},{value:"Solution 1a) Structural Sharing",id:"solution-1a-structural-sharing",level:2},{value:"External Resources",id:"external-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"react-query",children:"React Query"}),"\n",(0,i.jsx)(n.h2,{id:"problem-1",children:"Problem 1"}),"\n",(0,i.jsx)(n.p,{children:"Historical is being stored in a DynamoDB database and this data needs to be served to the frontend client."}),"\n",(0,i.jsx)(n.p,{children:"Some numbers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"~500mb per data point"}),"\n",(0,i.jsx)(n.li,{children:"1 data point logged every minute"}),"\n",(0,i.jsx)(n.li,{children:"Max database TTL (how long the data will stay in the database) of 1 month"}),"\n",(0,i.jsx)(n.li,{children:"1 database RCU (Read Capacity Unit) is defined as 1 x 4kb read per second\nBased on those numbers, a frontend client can potentially make a request for 43800 data points, which is about 21.9 mb."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If we take the lazy approach and just query the database every time the user uses the app, this will be uneconomical due to the following reasons"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"RCU usage: estimated to be about 58.4 RCU for an entire read"}),"\n",(0,i.jsx)(n.li,{children:"Network usage: It will cost at least 21.9 mb of data to for each data request, which could use up the user's data plan quickly if on mobile"}),"\n",(0,i.jsxs)(n.li,{children:["Speed: This much data will cause significant hiccups in all areas of the data retrieval pipeline, not limited to:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"database querying"}),"\n",(0,i.jsx)(n.li,{children:"network sending"}),"\n",(0,i.jsx)(n.li,{children:"frontend loading"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"solution-1-frontend-caching",children:"Solution 1: Frontend Caching"}),"\n",(0,i.jsx)(n.p,{children:"We can cache the data on the frontend client."}),"\n",(0,i.jsx)(n.h3,{id:"overview",children:"Overview:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["On the initial load:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A full request will be performed"}),"\n",(0,i.jsx)(n.li,{children:"This data will then be cached."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["On subsequent loads:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"We will retrieve the most recent data from the cache"}),"\n",(0,i.jsx)(n.li,{children:"Extract the timestamp"}),"\n",(0,i.jsx)(n.li,{children:"Call the backend with the timestamp to only retrieve data past that timestamp"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"types-of-caches",children:"Types of Caches"}),"\n",(0,i.jsxs)(n.p,{children:["There are 2 main types of browser caches, ",(0,i.jsx)(n.strong,{children:"localStorage"})," and ",(0,i.jsx)(n.strong,{children:"indexedDB"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"local-session",children:"Local Session"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"5MB limit"}),"\n",(0,i.jsx)(n.li,{children:"Key-value storage"}),"\n",(0,i.jsx)(n.li,{children:"Synchronous operation (I.e. blocking)"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"indexeddb",children:"IndexedDB"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Much larger storage capacity, sometimes up to GBs"}),"\n",(0,i.jsx)(n.li,{children:"Can store JavaScript objects"}),"\n",(0,i.jsx)(n.li,{children:"Asynchronous operation"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For our usage, indexedDB seems to be the better choice, mainly due to the storage limit."}),"\n",(0,i.jsx)(n.h3,{id:"tanstack-query",children:"Tanstack Query"}),"\n",(0,i.jsx)(n.p,{children:"To achieve this, we will be using Tanstack Query (Formerly known as React Query). Tanstack Query is a data fetching and caching library for React (works with Next.js). It provides an abstraction layer over the browser cache, allowing us to easily store and retrieve data from the cache."}),"\n",(0,i.jsx)(n.h3,{id:"tanstack-query-options",children:"Tanstack Query Options"}),"\n",(0,i.jsx)(n.p,{children:"useQuery params:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"gcTime: The time in milliseconds that unused/inactive cache data remains in memory"}),"\n",(0,i.jsx)(n.li,{children:"staleTime: The time in milliseconds after data is considered stale"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"PersistQueryClientProvider options"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"maxAge: How long the data will stay in the cache"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All the above options should ideally be set to 1000 * 60 * 60 * 24 * 30 (which is 30 days). However, that causes the error"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"(node:42282) TimeoutOverflowWarning: 2592000000 does not fit into a 32-bit signed integer.\nTimeout duration was set to 1.\n"})}),"\n",(0,i.jsx)(n.p,{children:"Thus it is only set to 20 days."}),"\n",(0,i.jsx)(n.h2,{id:"problem-1a",children:"Problem 1a)"}),"\n",(0,i.jsx)(n.p,{children:"React Query's queryFn gets called on:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"When 'useQuery' mounts (on initial page load)"}),"\n",(0,i.jsx)(n.li,{children:"When window is refocused"}),"\n",(0,i.jsx)(n.li,{children:"on network reconnection"}),"\n",(0,i.jsx)(n.li,{children:"on every refetchInterval defined in the initialization of useQuery"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const { data, isLoading } = useQuery<EPData[], Error>({\n\nqueryKey: [queryKey],\n\nqueryFn: getEPData,\n\nenabled: isAuthTokenReady,\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"When using useQuery, I must supply queryFn. queryFn must return a Promise that resolves to data or an error. React Query will take this data as the most up-to-date data => it will invalidate the entire cache and write the data returned from queryFn into the cache."}),"\n",(0,i.jsx)(n.p,{children:"With up to 50k data points, a read will take around 1 minute, with a write being most probably longer. This is unacceptable."}),"\n",(0,i.jsx)(n.h2,{id:"solution-1a-structural-sharing",children:"Solution 1a) Structural Sharing"}),"\n",(0,i.jsxs)(n.p,{children:["Query results by default are\xa0",(0,i.jsx)(n.strong,{children:"structurally shared to detect if data has actually changed"}),"\xa0and if not,\xa0",(0,i.jsx)(n.strong,{children:"the data reference remains unchanged"})]}),"\n",(0,i.jsx)(n.h2,{id:"external-resources",children:"External Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/react/reference/useQuery",children:"Tanstack (FKA React) Query documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://browsee.io/blog/unleashing-the-power-a-comparative-analysis-of-indexdb-local-storage-and-session-storage/",children:"Browser localStorage vs indexedDB"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var i=t(7294);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);